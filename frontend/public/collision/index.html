<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Simulador de Impacto de Meteoro</title>
    <script src="https://cesium.com/downloads/cesiumjs/releases/1.117/Build/Cesium/Cesium.js"></script>
    <link href="https://cesium.com/downloads/cesiumjs/releases/1.117/Build/Cesium/Widgets/widgets.css" rel="stylesheet">
    <style>
        html,
        body,
        #cesiumContainer {
            width: 100%;
            height: 100%;
            margin: 0;
            padding: 0;
            overflow: hidden;
        }

        #controls {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(42, 42, 42, 0.9);
            color: white;
            padding: 15px;
            border-radius: 8px;
            z-index: 1000;
            font-family: Arial, sans-serif;
            max-width: 300px;
        }

        /* Painel de resultados à direita */
        #results {
            position: absolute;
            top: 20px; /* um pouco mais para baixo */
            right: 10px;
            background: rgba(42, 42, 42, 0.9);
            color: white;
            padding: 15px;
            border-radius: 8px;
            z-index: 1000;
            font-family: Arial, sans-serif;
            max-width: 320px;
            min-width: 260px;
            display: none;
            /* aparece somente após a primeira simulação */
        }

        #results h3 { margin: 0 0 10px; }
        #results .row { display: flex; justify-content: space-between; gap: 10px; margin: 6px 0; }
        #results .label { color: #ddd; font-size: 12px; }
        #results .value { font-weight: 700; font-size: 13px; background: rgba(255,255,255,0.12); padding: 2px 6px; border-radius: 4px; }

        #controls button {
            background: #ff4444;
            color: white;
            border: none;
            padding: 10px 15px;
            margin: 5px;
            border-radius: 5px;
            cursor: pointer;
            font-weight: bold;
        }

        #controls button:hover {
            background: #ff6666;
        }

        #controls button:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            filter: grayscale(20%);
        }

        #impact-info {
            margin-top: 10px;
            font-size: 12px;
            line-height: 1.4;
        }

        .control {
            margin: 8px 0 14px;
        }

        .control label {
            display: block;
            margin-bottom: 6px;
            font-size: 13px;
        }

        .control input[type="range"],
        .control select {
            width: 100%;
        }

        .value-badge {
            display: inline-block;
            background: rgba(255, 255, 255, 0.12);
            padding: 2px 6px;
            border-radius: 4px;
            margin-left: 6px;
            font-weight: 600;
        }

        .stepper {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-top: 4px;
        }

        .stepper button {
            background: #2b2b2b;
            color: #fff;
            border: 1px solid rgba(255, 255, 255, 0.2);
            width: 28px;
            height: 28px;
            border-radius: 4px;
            cursor: pointer;
            font-weight: 700;
            line-height: 1;
        }

        .stepper-value {
            min-width: 72px;
            text-align: center;
            font-weight: 600;
        }

        .material-info {
            display: block;
            margin-top: 6px;
            color: #ddd;
        }

        /* Linha do seletor de material junto do rótulo */
        .material-inline {
            display: flex;
            align-items: center;
            gap: 8px;
            justify-content: space-between;
        }
    </style>
</head>

<body>
    <div id="cesiumContainer"></div>

    <!-- Elementos de áudio para efeitos sonoros -->
    <audio id="meteorFallSound" preload="auto">
        <source src="./sounds/meteor-impact-sound-effect.mp3" type="audio/mp3">

    </audio>

    <!-- Overlay de imagem do meteoro durante o impacto -->
    <div id="meteorImpactOverlay" style="
        position: fixed;
        top: 0;
        left: 0;
        width: 100vw;
        height: 100vh;
        background: radial-gradient(circle, rgba(255,100,0,0.8) 0%, rgba(255,0,0,0.4) 30%, transparent 70%);
        pointer-events: none;
        z-index: 9999;
        display: none;
        animation: impactFlash 3s ease-out;
    ">

        <!-- Efeito de ondas de choque -->
        <div style="
            position: absolute;
            top: 50%;
            left: 50%;
            width: 10px;
            height: 10px;
            border: 3px solid rgba(255,255,255,0.8);
            border-radius: 50%;
            transform: translate(-50%, -50%);
            animation: shockwave 2s ease-out 1s;
        "></div>
    </div>

    <style>
        /* @keyframes impactFlash {
            0% {
                opacity: 0;
            }

            15% {
                opacity: 0.8;
                background: radial-gradient(circle, rgba(255, 255, 255, 0.9) 0%, rgba(255, 100, 0, 0.6) 40%, transparent 80%);
            }

            30% {
                opacity: 1;
            }

            100% {
                opacity: 0;
            }
        } */

        @keyframes meteorFall {
            0% {
                transform: translate(-300vw, -300vh) rotate(45deg) scale(0.2);
                opacity: 0.3;
            }

            20% {
                opacity: 0.8;
            }

            80% {
                opacity: 1;
                transform: translate(-50%, -50%) rotate(45deg) scale(1.8);
            }

            100% {
                transform: translate(-50%, -50%) rotate(45deg) scale(2.5);
                opacity: 0;
            }
        }

        @keyframes shockwave {
            0% {
                width: 10px;
                height: 10px;
                opacity: 1;
            }

            100% {
                width: 100vw;
                height: 100vw;
                opacity: 0;
            }
        }
    </style>

    <div id="controls">
        <h3>Meteor Impact Simulator</h3>
        <button id="simulateBtn" onclick="simulateImpact()" disabled>Simulate Impact</button>
        <button onclick="resetSimulation()">Reset</button>
        <div id="impact-info">
            <div class="control">
                <label for="diameterRange">Meteor Diameter
                    <span class="value-badge" id="diameterOut">50 m</span>
                </label>
                <input type="range" id="diameterRange" min="1" max="1500" step="1" value="50">
            </div>

            <div class="control">
                <label for="velocityRange">Meteor Speed
                    <span class="value-badge" id="velocityOut">20 km/s</span>
                </label>
                <input type="range" id="velocityRange" min="11" max="72" step="1" value="20">
            </div>

            <div class="control">
                <label for="angleRange">Angle of impact
                    <span class="value-badge" id="angleOut">45°</span>
                </label>
                <input type="range" id="angleRange" min="5" max="90" step="1" value="45">
            </div>

            <div class="control">
                <div class="material-inline">
                    <label style="margin: 0">Material</label>
                    <div class="stepper" role="group" aria-label="Selecionar material">
                        <button id="materialPrev" type="button" aria-label="Material anterior">&#8249;</button>
                        <span class="stepper-value" id="materialValue">stone</span>
                        <button id="materialNext" type="button" aria-label="Próximo material">&#8250;</button>
                    </div>
                </div>
                <small class="material-info">Density: <span id="materialDensity">2500</span> kg/m³</small>
            </div>

            <em id="selectHint">💡 Click on the map to choose the target!</em>
            <button id="simulateBtn" onclick="returnHome()" >Return</button>
            <button id="simulateBtn" onclick="nextSession()" disabled>Next</button>
        </div>
    </div>

    <!-- Painel de resultados à direita -->
    <div id="results" aria-live="polite">
        <h3>Resultados</h3>
        <div class="row"><span class="label">Cratera (Ø transiente)</span><span class="value" id="r-diametroCratera">—</span></div>
        <div class="row"><span class="label">Profundidade cratera</span><span class="value" id="r-profundidadeCratera">—</span></div>
        <div class="row"><span class="label">Energia do impacto</span><span class="value" id="r-energiaImpacto">—</span></div>
        <div class="row"><span class="label">Energia (TNT)</span><span class="value" id="r-energiaTNT">—</span></div>
        <div class="row"><span class="label">Energia (Megatons)</span><span class="value" id="r-energiaMTNT">—</span>
        </div>
        <div class="row"><span class="label">Fireball (diâmetro)</span><span class="value" id="r-fireball">—</span>
        </div>
        <div class="row"><span class="label">Queimaduras leves</span><span class="value" id="r-first">—</span></div>
        <div class="row"><span class="label">Queimaduras 2º grau</span><span class="value" id="r-second">—</span></div>
        <div class="row"><span class="label">Queimaduras 3º grau</span><span class="value" id="r-third">—</span></div>
        <div class="row"><span class="label">Risco roupas pegarem fogo</span><span class="value" id="r-clothes">—</span>
        </div>
        <div class="row"><span class="label">Estimativa de mortes</span><span class="value" id="r-deaths">—</span></div>
        <div class="row"><span class="label">Estimativa de feridos</span><span class="value" id="r-feridos">—</span>
        </div>
    </div>
    <script src="./lib/calculator.js"></script>
    <script>

        function returnHome(){
            window.top.location.href = '/home';
            window.location.replace('/home');
        }

        function nextSession(){
            /* Decidir ainda para qual página seguir depois da simulação */
            window.top.location.href = '/terminal-landing';
            window.location.replace('/terminal-landing');
        }

        // Token de acesso do Cesium ion
        Cesium.Ion.defaultAccessToken = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJqdGkiOiJjMGRkYjMwYy1lODg0LTQ3MTktOTBiNi02ZDI0YjRiNTcxNjIiLCJpZCI6MzQ3MjQ2LCJpYXQiOjE3NTk2MDg1NzN9.901R3lkV1aC6zsOj843KhI37YOCw7lOnqS8rHd4nVq8';

        // --- PARÂMETROS DA CRATERA ---
        let craterMajorRadius = 1500;
        let craterMinorRadius = 1500;
        let craterDepth = 400;
        let craterRotation = 45;
        let craterCapCutoffHeight = 0;

        // Variáveis globais
        let viewer;
        let meteorEntity;
        let explosionEntity;
        let impactZones = [];
        let region = { longitude: null, latitude: null }; // Posição inicial (Brasília, Brasil)
        let craterCapClippingPlanes; // Para gerenciar os ClippingPlanes da calota

        let targetMarker = null; // Marcador do alvo selecionado
    let craterModel = null; // Modelo 3D da cratera
    let terrainHeight = 0; // Altura do terreno no alvo (atualizada no clique)
    // Unidade de exibição (visual apenas): 'metric' (m/km) ou 'imperial' (mi)
    let displayUnit = 'metric';
    // Cache do último resultado para re-render quando alternar unidades
    let lastResults = null;

        // --- VARIÁVEIS DE CONTROLE DO USUÁRIO (para cálculos posteriores) ---
        let meteorDiameterM = 50;      // 1 m a 1500 m (1.5 km)
        let meteorVelocityKms = 20;    // 1 a 100 km/s
        let impactAngleDeg = 45;       // 5° a 90°

        // Materiais e densidades (kg/m³)
        const MATERIALS = [
            { key: 'ice', density: 920 },
            { key: 'stone', density: 2500 },
            { key: 'carbon', density: 3500 },
            { key: 'iron', density: 7800 },
        ];

        // Estado atual do material
        let meteorMaterial = { key: 'stone', density: 2500 };

        // Legendas
        const labelAlpha = 0.9;
        const labelBrightness = 1;

        // Crater
        const craterModelUri = "./crater_with_cone.glb";

        // === FUNÇÕES DE ÁUDIO E EFEITOS VISUAIS ===

        // Função para tocar som de meteoro caindo
        function playMeteorFallSound() {
            const audio = document.getElementById('meteorFallSound');
            try {
                audio.currentTime = 0; // Reinicia o áudio
                audio.volume = 0.7; // Volume moderado
                audio.play().catch(error => {
                    console.warn('Não foi possível tocar som do meteoro:', error);
                    // Fallback: criar som sintético com Web Audio API
                    generateSyntheticMeteorSound();
                });
            } catch (error) {
                console.warn('Erro ao tentar tocar áudio:', error);
            }
        }

        // Função para tocar som de explosão
        function playExplosionSound() {
            const audio = document.getElementById('explosionSound');
            try {
                audio.currentTime = 0;
                audio.volume = 0.8; // Volume mais alto para explosão
                audio.play().catch(error => {
                    console.warn('Não foi possível tocar som da explosão:', error);
                    // Fallback: criar som sintético
                    generateSyntheticExplosionSound();
                });
            } catch (error) {
                console.warn('Erro ao tentar tocar áudio de explosão:', error);
            }
        }

        // Função para mostrar efeito visual de impacto
        function showMeteorImpactEffect() {
            const overlay = document.getElementById('meteorImpactOverlay');
            overlay.style.display = 'block';

            // Remove o overlay após a animação
            setTimeout(() => {
                overlay.style.display = 'none';
            }, 4000); // Aumentado para 4 segundos para coincidir com as animações
        }

        // Fallback: gerar som sintético de meteoro usando Web Audio API
        function generateSyntheticMeteorSound() {
            try {
                const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();

                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);

                // Som de "whoosh" do meteoro
                oscillator.frequency.setValueAtTime(200, audioContext.currentTime);
                oscillator.frequency.exponentialRampToValueAtTime(50, audioContext.currentTime + 3);

                gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 3);

                oscillator.start();
                oscillator.stop(audioContext.currentTime + 3);
            } catch (error) {
                console.warn('Não foi possível gerar som sintético:', error);
            }
        }

        // Fallback: gerar som sintético de explosão
        function generateSyntheticExplosionSound() {
            try {
                const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();

                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);

                // Som grave de explosão
                oscillator.frequency.setValueAtTime(80, audioContext.currentTime);
                oscillator.frequency.exponentialRampToValueAtTime(20, audioContext.currentTime + 2);

                gainNode.gain.setValueAtTime(0.5, audioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 2);

                oscillator.start();
                oscillator.stop(audioContext.currentTime + 2);
            } catch (error) {
                console.warn('Não foi possível gerar som sintético de explosão:', error);
            }
        }

        // === FIM DAS FUNÇÕES DE ÁUDIO E EFEITOS ===

        // Aguarda o DOM estar pronto
        document.addEventListener('DOMContentLoaded', async function () {
            try {
                viewer = new Cesium.Viewer('cesiumContainer', {
                    terrain: Cesium.Terrain.fromWorldTerrain(),
                    sceneModePicker: false,
                    animation: false,
                    timeline: false,
                });

                // Camada adicional de labels
                const labelsLayer = viewer.imageryLayers.addImageryProvider(
                    new Cesium.OpenStreetMapImageryProvider({
                        url: 'https://cartodb-basemaps-a.global.ssl.fastly.net/light_only_labels/',
                        fileExtension: 'png',
                        credit: 'CartoDB'
                    })
                );
                labelsLayer.alpha = labelAlpha;
                labelsLayer.brightness = labelBrightness;

                viewer.cesiumWidget.creditContainer.style.display = "none";
                viewer.scene.globe.depthTestAgainstTerrain = true;

                // Inicia com visão global do globo (sem alvo inicial)
                viewer.camera.setView({
                    destination: Cesium.Cartesian3.fromDegrees(-79.186, 12.915, 15000000),
                    orientation: {
                        heading: Cesium.Math.toRadians(0.0),
                        pitch: Cesium.Math.toRadians(-90.0),
                        roll: 0.0
                    }
                });

                // Move o botão de "Navigation Instructions" para o lado esquerdo, abaixo do painel de controles
                (function moveNavigationHelpToLeft() {
                    try {
                        const navHelp = viewer?.navigationHelpButton?.container;
                        if (!navHelp) return;
                        const controlsEl = document.getElementById('controls');
                        let topPx = 10;
                        if (controlsEl) {
                            const rect = controlsEl.getBoundingClientRect();
                            topPx = Math.round(rect.top + rect.height + 10);
                        }
                        navHelp.style.position = 'fixed';
                        navHelp.style.left = '10px';
                        navHelp.style.right = 'auto';
                        navHelp.style.top = `${topPx}px`;
                        navHelp.style.zIndex = 2001;
                        navHelp.style.overflow = 'visible';
                        // leva o elemento para o body para posicionamento fixo consistente
                        document.body.appendChild(navHelp);

                        // Garante que o painel de instruções abra para a direita quando o botão estiver à esquerda
                        const adjustPanel = () => {
                            try {
                                const divs = navHelp.querySelectorAll('div');
                                for (const d of divs) {
                                    const cs = window.getComputedStyle(d);
                                    // Heurística: o painel costuma ser absoluto e ancorado por right
                                    if (cs.position === 'absolute' && (cs.right !== 'auto' || d.style.right)) {
                                        d.style.right = 'auto';
                                        d.style.left = '40px';
                                        d.style.maxWidth = '280px';
                                        d.style.zIndex = 2002;
                                    }
                                }
                            } catch {}
                        };
                        // Ajusta ao abrir/fechar
                        navHelp.addEventListener('click', () => setTimeout(adjustPanel, 0));
                        // Ajuste inicial preventivo
                        setTimeout(adjustPanel, 0);
                    } catch (e) {
                        console.warn('Não foi possível mover o botão de instruções de navegação:', e);
                    }
                })();

                // Adiciona handler de clique no mapa
                const handler = new Cesium.ScreenSpaceEventHandler(viewer.scene.canvas);
                handler.setInputAction(function (movement) {
                    const cartesian = viewer.scene.pickPosition(movement.position);

                    if (Cesium.defined(cartesian)) {
                        const cartographic = Cesium.Cartographic.fromCartesian(cartesian);
                        const longitude = Cesium.Math.toDegrees(cartographic.longitude);
                        const latitude = Cesium.Math.toDegrees(cartographic.latitude);
                        const height = cartographic.height;

                        terrainHeight = height;

                        console.log(`Alvo definido em: Lon ${longitude.toFixed(3)}, Lat ${latitude.toFixed(3)}, Altura: ${height.toFixed(2)} metros`);

                        // Atualiza posição do alvo
                        region.longitude = longitude;
                        region.latitude = latitude;

                        if (targetMarker) {
                            viewer.entities.remove(targetMarker);
                        }

                        targetMarker = viewer.entities.add({
                            position: cartesian,
                            point: {
                                pixelSize: 20,
                                color: Cesium.Color.RED,
                                outlineColor: Cesium.Color.WHITE,
                                outlineWidth: 3,
                                heightReference: Cesium.HeightReference.CLAMP_TO_GROUND
                            }
                        });

                        // Habilita simulação e esconde dica após selecionar alvo
                        const btn = document.getElementById('simulateBtn');
                        if (btn) btn.disabled = false;
                        const hint = document.getElementById('selectHint');
                        if (hint) hint.style.display = 'none';

                        console.log('Alvo definido em:', longitude.toFixed(3), latitude.toFixed(3));
                    }
                }, Cesium.ScreenSpaceEventType.LEFT_CLICK);

                // --- CONTROLES UI: ligar sliders e seletor ---
                const $ = (id) => document.getElementById(id);
                const diameterRange = $('diameterRange');
                const velocityRange = $('velocityRange');
                const angleRange = $('angleRange');
                const materialPrev = $('materialPrev');
                const materialNext = $('materialNext');
                const diameterOut = $('diameterOut');
                const velocityOut = $('velocityOut');
                const angleOut = $('angleOut');
                const materialValue = $('materialValue');
                const materialDensity = $('materialDensity');

                const fmtMeters = (m) => m >= 1000 ? `${(m / 1000).toFixed(1)} km` : `${m} m`;

                const syncUI = () => {
                    diameterOut.textContent = fmtMeters(meteorDiameterM);
                    velocityOut.textContent = `${meteorVelocityKms} km/s`;
                    angleOut.textContent = `${impactAngleDeg}°`;
                    materialValue.textContent = meteorMaterial.key;
                    materialDensity.textContent = meteorMaterial.density;
                };

                // Inicializa valores nos inputs a partir das variáveis globais
                diameterRange.value = meteorDiameterM;
                velocityRange.value = meteorVelocityKms;
                angleRange.value = impactAngleDeg;
                syncUI();

                diameterRange.addEventListener('input', () => {
                    meteorDiameterM = parseInt(diameterRange.value, 10);
                    diameterOut.textContent = fmtMeters(meteorDiameterM);
                });

                velocityRange.addEventListener('input', () => {
                    meteorVelocityKms = parseInt(velocityRange.value, 10);
                    velocityOut.textContent = `${meteorVelocityKms} km/s`;
                });

                angleRange.addEventListener('input', () => {
                    impactAngleDeg = parseInt(angleRange.value, 10);
                    angleOut.textContent = `${impactAngleDeg}°`;
                });

                const currentMaterialIndex = () => MATERIALS.findIndex(m => m.key === meteorMaterial.key);

                const stepMaterial = (dir) => {
                    const idx = currentMaterialIndex();
                    const nextIdx = (idx + dir + MATERIALS.length) % MATERIALS.length;
                    meteorMaterial = MATERIALS[nextIdx];
                    syncUI();
                };

                materialPrev.addEventListener('click', () => stepMaterial(-1));
                materialNext.addEventListener('click', () => stepMaterial(1));

                // Liga o botão de alternância de unidades do painel de resultados
                const unitToggleBtn = document.getElementById('unitToggle');
                if (unitToggleBtn) unitToggleBtn.addEventListener('click', toggleUnits);

            } catch (error) { console.error('Erro ao inicializar simulador:', error); }
        });

        // Função para simular o impacto do meteoro
        async function simulateImpact() {
            // Bloqueia simulação sem alvo selecionado
            if (region.longitude == null || region.latitude == null) {
                alert('Clique no mapa para escolher o alvo primeiro.');
                return;
            }
            // Exemplo: log dos parâmetros selecionados (para debugging e futuros cálculos)
            //console.log('[Parâmetros]', {
            //    region : region,
            //    diameter_m: meteorDiameterM,
            //    velocity_kms: meteorVelocityKms,
            //    angle_deg: impactAngleDeg,
            //    material: meteorMaterial
            //});

            const parameters = {
                diameter: meteorDiameterM,
                velocity: meteorVelocityKms,
                angle: impactAngleDeg,
                density: meteorMaterial.density,
                lat: region.latitude,
                lon: region.longitude
            };

            const popDensity = await getPopulationDensity(region.latitude, region.longitude);
            const results = getMeteorData(parameters.diameter, 'm', parameters.density, parameters.velocity, 'km/s', parameters.angle, -1, popDensity);
            craterMinorRadius = results.diametroCrateraTransiente;
            craterMajorRadius = results.diametroCrateraTransiente;
            craterDepth = results.profundidadeCrateraTrasiente;
            // Atualiza painel de resultados
            updateResultsPanel(results);
            // Mostra o painel de resultados após a primeira simulação
            const resultsPanel = document.getElementById('results');
            if (resultsPanel) resultsPanel.style.display = 'block';

            resetSimulation();

            // === EFEITOS SONOROS E VISUAIS DO METEORO ===
            // Toca som do meteoro caindo e mostra efeito visual
            playMeteorFallSound();
            showMeteorImpactEffect();

            //createMeteor();
            setTimeout(() => {
                // Toca som da explosão no momento do impacto
                playExplosionSound();
                createExplosion(results.diameterFireball);
                removeMeteor();
            }, 3000);
            setTimeout(() => {
                const impactPosition = Cesium.Cartesian3.fromDegrees(region.longitude, region.latitude);
                //createRealCrater(impactPosition, craterMajorRadius, craterMinorRadius, craterDepth, craterRotation);
                // --- CHAMANDO A NOVA FUNÇÃO DA CALOTA COM CORTE ---
                createCraterWithTerrain(impactPosition, craterMajorRadius, craterDepth);

                removeExplosion();
            }, 4000);
            setTimeout(() => {
                console.log(results);
                // Chamada corrigida: thirdDegreeBurn, secondDegreeBurn, firstDegreeBurn
                createDestructionZones(results.thirdDegreeBurn, results.secondDegreeBurn, results.firstDegreeBurn);
            }, 6000);
        }

        // Atualiza o painel de resultados à direita
        function updateResultsPanel(res) {
            // guarda último resultado para alternância de unidades
            lastResults = res;
            const isNum = (v) => Number.isFinite(v);
            const byId = (id) => document.getElementById(id);
            const setText = (id, text) => {
                const el = byId(id);
                if (!el) {
                    // Evita quebra caso o elemento não exista por alguma razão de renderização
                    console.warn(`[results] elemento não encontrado: #${id}`);
                    return;
                }
                el.textContent = text;
            };
            const fmtDistance = (m) => {
                if (!isNum(m)) return '—';
                if (Math.abs(m) >= 1000) return `${(m/1000).toFixed(2)} km`;
                return `${m} m`;
            };
            const fmtEnergyJ = (j) => {
                if (!isNum(j)) return '—';
                const units = [
                    { u: 'J', v: 1 },
                    { u: 'kJ', v: 1e3 },
                    { u: 'MJ', v: 1e6 },
                    { u: 'GJ', v: 1e9 },
                    { u: 'TJ', v: 1e12 },
                    { u: 'PJ', v: 1e15 }
                ];
                let picked = units[0];
                for (const cand of units) if (j >= cand.v) picked = cand;
                return `${(j / picked.v).toFixed(2)} ${picked.u}`;
            };
            const fmtInt = (n) => {
                if (!isNum(n)) return '—';
                return n.toLocaleString('pt-BR');
            };

            setText('r-diametroCratera', fmtDistance(res.diametroCrateraTransiente));
            setText('r-profundidadeCratera', fmtDistance(res.profundidadeCrateraTrasiente));
            setText('r-energiaImpacto', fmtEnergyJ(res.energiaDoImpacto));
            setText('r-energiaTNT', `${fmtInt(res.energiaDoImpactoTNT)} t TNT`);
            setText('r-energiaMTNT', `${fmtInt(res.energiaDoImpactoMTNT)} Mt TNT`);
            setText('r-fireball', fmtDistance(res.diameterFireball));
            setText('r-first', fmtDistance(res.firstDegreeBurn));
            setText('r-second', fmtDistance(res.secondDegreeBurn));
            setText('r-third', fmtDistance(res.thirdDegreeBurn));
            setText('r-clothes', fmtDistance(res.clothesBurn));
            setText('r-deaths', fmtInt(res.deaths));
            setText('r-feridos', fmtInt(res.feridos));
        }

        // Alternância visual de unidades (não altera nenhum cálculo)
        function toggleUnits() {
            displayUnit = displayUnit === 'metric' ? 'imperial' : 'metric';
            const btn = document.getElementById('unitToggle');
            if (btn) btn.textContent = displayUnit === 'metric' ? 'mi' : 'km';
            if (lastResults) updateResultsPanel(lastResults);
        }

        // Função para criar cratera
        function createCraterWithTerrain(position, radius, depth) {
            // 1. Corta o terreno em formato circular
            const clippingPlanes = [];
            const numSides = 64;
            const points = [];

            for (let i = 0; i < numSides; i++) {
                const angle = Cesium.Math.TWO_PI * (i / numSides);
                points.push(new Cesium.Cartesian2(
                    radius * Math.cos(angle),
                    radius * Math.sin(angle)
                ));
            }

            for (let i = 0; i < numSides; i++) {
                const j = (i + 1) % numSides;
                const mid = Cesium.Cartesian2.multiplyByScalar(
                    Cesium.Cartesian2.add(points[i], points[j], new Cesium.Cartesian2()),
                    0.5, new Cesium.Cartesian2()
                );
                const normal = Cesium.Cartesian2.normalize(
                    Cesium.Cartesian2.subtract(points[j], points[i], new Cesium.Cartesian2()),
                    new Cesium.Cartesian2()
                );
                const tmp = normal.x;
                normal.x = -normal.y;
                normal.y = tmp;

                clippingPlanes.push(
                    new Cesium.ClippingPlane(new Cesium.Cartesian3(normal.x, normal.y, 0.0), -Cesium.Cartesian2.magnitude(mid))
                );
            }

            clippingPlanes.push(new Cesium.ClippingPlane(new Cesium.Cartesian3(0.0, 0.0, -1.0), terrainHeight - (depth)));

            viewer.scene.globe.clippingPlanes = new Cesium.ClippingPlaneCollection({
                planes: clippingPlanes,
                edgeWidth: 2.0,
                edgeColor: Cesium.Color.DARKRED,
                modelMatrix: Cesium.Transforms.eastNorthUpToFixedFrame(position),
                enabled: true
            });

            // 2. Adiciona o modelo GLB da cratera
            if (craterModel) {
                viewer.entities.remove(craterModel);
                craterModel = null;
            }

            const cartographic = Cesium.Cartographic.fromCartesian(position);
            const longitude = Cesium.Math.toDegrees(cartographic.longitude);
            const latitude = Cesium.Math.toDegrees(cartographic.latitude);

            const centeredPosition = Cesium.Cartesian3.fromDegrees(
                longitude,
                latitude,
                terrainHeight - (depth * 6.7)
            );

            // Escala proporcional ao raio da cratera
            const craterScale = radius * 25;

            craterModel = viewer.entities.add({
                position: centeredPosition,
                model: {
                    uri: craterModelUri,
                    scale: craterScale,
                    minimumPixelSize: 64,
                    maximumScale: craterScale,
                    color: Cesium.Color.GRAY
                }
            });

            console.log(`Cratera carregada em lon:${longitude.toFixed(3)}, lat:${latitude.toFixed(3)}, altura:${terrainHeight.toFixed(2)}m`);
        }

        function resetSimulation() {
            if (meteorEntity) viewer.entities.remove(meteorEntity);
            if (explosionEntity) viewer.entities.remove(explosionEntity);
            if (craterModel) {
                viewer.entities.remove(craterModel);
                craterModel = null;
            }

            meteorEntity = explosionEntity = null;

            impactZones.forEach(zone => viewer.entities.remove(zone));
            impactZones = [];

            if (viewer.scene.globe.clippingPlanes) {
                viewer.scene.globe.clippingPlanes.enabled = false;
                viewer.scene.globe.clippingPlanes = undefined;
            }

            // Não remove o targetMarker para manter o alvo selecionado

            // Se há alvo, volta para ele; caso contrário, mantém visão global
            if (region.longitude != null && region.latitude != null) {
                viewer.camera.flyTo({
                    destination: Cesium.Cartesian3.fromDegrees(region.longitude, region.latitude, 80000),
                    orientation: { heading: Cesium.Math.toRadians(0.0), pitch: Cesium.Math.toRadians(-90.0), roll: 0.0 },
                    duration: 0
                });
            } else {
                viewer.camera.setView({
                    destination: Cesium.Cartesian3.fromDegrees(0, 0, 3.2e7),
                    orientation: { heading: Cesium.Math.toRadians(0.0), pitch: Cesium.Math.toRadians(-25.0), roll: 0.0 }
                });
            }
        }

        // --- DEMAIS FUNÇÕES (SEM ALTERAÇÃO) ---
        function createDestroyedGroundTexture() { const canvas = document.createElement('canvas'); canvas.width = 512; canvas.height = 512; const ctx = canvas.getContext('2d'); const gradient = ctx.createRadialGradient(256, 256, 0, 256, 256, 256); gradient.addColorStop(0, '#1a0f0a'); gradient.addColorStop(.5, '#4a2c1a'); gradient.addColorStop(.9, '#8b5a3c'); ctx.fillStyle = gradient; ctx.fillRect(0, 0, 512, 512); ctx.strokeStyle = 'rgba(0, 0, 0, 0.8)'; ctx.lineWidth = 3; for (let i = 0; i < 30; i++) { ctx.beginPath(); ctx.moveTo(256 + Math.random() * 200 - 100, 256 + Math.random() * 200 - 100); ctx.lineTo(256 + Math.random() * 240 - 120, 256 + Math.random() * 240 - 120); ctx.stroke() } return canvas.toDataURL() }
        function createMeteor() { const startTime = viewer.clock.currentTime; const endTime = Cesium.JulianDate.addSeconds(startTime, 3, new Cesium.JulianDate()); const startPosition = Cesium.Cartesian3.fromDegrees(region.longitude - 1, region.latitude + 1, 15e4); const endPosition = Cesium.Cartesian3.fromDegrees(region.longitude, region.latitude, 0); const positionProperty = new Cesium.SampledPositionProperty(); positionProperty.addSample(startTime, startPosition); positionProperty.addSample(endTime, endPosition); meteorEntity = viewer.entities.add({ name: "Meteoro", position: positionProperty, point: { pixelSize: 35, color: Cesium.Color.ORANGE, outlineColor: Cesium.Color.RED, outlineWidth: 4, scaleByDistance: new Cesium.NearFarScalar(1e3, 2, 1e5, .5) }, path: { show: !0, leadTime: 0, trailTime: 2, width: 10, resolution: 1, material: new Cesium.PolylineGlowMaterialProperty({ glowPower: .5, color: Cesium.Color.ORANGE, taperPower: .7 }) } }); viewer.camera.setView({ destination: Cesium.Cartesian3.fromDegrees(region.longitude, region.latitude, 6e4), orientation: { heading: Cesium.Math.toRadians(0), pitch: Cesium.Math.toRadians(-90), roll: 0 } }) }
        function removeMeteor() { if (meteorEntity) { viewer.entities.remove(meteorEntity); meteorEntity = null; } }
        function createExplosion(diameterFireball) { explosionEntity = viewer.entities.add({ name: "Explosão", position: Cesium.Cartesian3.fromDegrees(region.longitude, region.latitude, 1e3), ellipse: { semiMinorAxis: diameterFireball, semiMajorAxis: diameterFireball, height: 1e3, material: new Cesium.ColorMaterialProperty(new Cesium.CallbackProperty(function (e, t) { const i = Math.sin(Cesium.JulianDate.secondsDifference(e, viewer.clock.currentTime) * 10) * 0.5 + .5; return Cesium.Color.ORANGE.withAlpha(i * 0.8) }, !1)), outline: !0, outlineColor: Cesium.Color.RED } }) }
        function removeExplosion() { if (explosionEntity) { viewer.entities.remove(explosionEntity); explosionEntity = null; } }
        function createDestructionZones(thirdDegreeBurnRadius, secondDegreeBurnRadius, firstDegreeBurnRadius) {
            // Zona Vermelha: Queimaduras de 3º grau
            const redZone = viewer.entities.add({
                name: "Queimaduras de 3º Grau",
                position: Cesium.Cartesian3.fromDegrees(region.longitude, region.latitude),
                ellipse: {
                    semiMinorAxis: thirdDegreeBurnRadius,
                    semiMajorAxis: thirdDegreeBurnRadius,
                    material: Cesium.Color.RED.withAlpha(.35),
                    outline: true,
                    outlineColor: Cesium.Color.DARKRED,
                    outlineWidth: 3,
                    heightReference: Cesium.HeightReference.CLAMP_TO_GROUND
                }
            });

            // Zona Laranja: Queimaduras de 2º grau
            const orangeZone = viewer.entities.add({
                name: "Queimaduras de 2º Grau",
                position: Cesium.Cartesian3.fromDegrees(region.longitude, region.latitude),
                ellipse: {
                    semiMinorAxis: secondDegreeBurnRadius,
                    semiMajorAxis: secondDegreeBurnRadius,
                    material: Cesium.Color.ORANGE.withAlpha(.3),
                    outline: true,
                    outlineColor: Cesium.Color.DARKORANGE,
                    outlineWidth: 2,
                    heightReference: Cesium.HeightReference.CLAMP_TO_GROUND
                }
            });

            // Zona Amarela: Queimaduras de 1º grau
            const yellowZone = viewer.entities.add({
                name: "Queimaduras de 1º Grau",
                position: Cesium.Cartesian3.fromDegrees(region.longitude, region.latitude),
                ellipse: {
                    semiMinorAxis: firstDegreeBurnRadius,
                    semiMajorAxis: firstDegreeBurnRadius,
                    material: Cesium.Color.YELLOW.withAlpha(.25),
                    outline: true,
                    outlineColor: Cesium.Color.GOLD,
                    outlineWidth: 2,
                    heightReference: Cesium.HeightReference.CLAMP_TO_GROUND
                }
            });

            impactZones.push(redZone, orangeZone, yellowZone);

            // Foca a câmera para mostrar a maior zona de destruição
            const maxRadius = Math.max(firstDegreeBurnRadius, secondDegreeBurnRadius, thirdDegreeBurnRadius);
            const cameraAltitude = maxRadius * 4; // Ajuste este multiplicador para o zoom desejado

            viewer.camera.flyTo({
                destination: Cesium.Cartesian3.fromDegrees(region.longitude, region.latitude, cameraAltitude),
                orientation: {
                    heading: Cesium.Math.toRadians(0),
                    pitch: Cesium.Math.toRadians(-90),
                    roll: 0
                },
                duration: 3
            });
        }

    </script>
</body>

</html>